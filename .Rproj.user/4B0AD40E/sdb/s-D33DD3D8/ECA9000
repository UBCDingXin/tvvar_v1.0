{
    "collab_server" : "",
    "contents" : "library(flare)\nlibrary(igraph)\nlibrary(lpSolve)\nlibrary(mnormt)\nlibrary(matrixcalc)\nlibrary(pracma)\nlibrary(MASS)\nlibrary(doParallel)\nlibrary(foreach)\nlibrary(parallel)\nlibrary(abind)\nlibrary(compiler)\nenableJIT(3)\n\nweight_epanechnikovker <- function(t, m, n, b)\n{\n  v = (t-m/n)/b\n  if(abs(v) > 1)\n  {\n    return(0)\n  }\n  else\n  {\n    #Epanechnikov\n    numerator = 0.75 * (1 - v^2)\n    vi=sapply(1:n,function(x){(t-x/n)/b})\n    indx=abs(vi)<=1\n    denumerator=sum(0.75*(1-vi[indx]^2))\n    return(numerator/denumerator)\n  }\n}\nvc_weight_epanechnikovker<-Vectorize(weight_epanechnikovker,vectorize.args='m')#vectorization of a scalar function\nvc_weight_epanechnikovker=cmpfun(vc_weight_epanechnikovker)\n\n\n#' fit a TV_VAR model\n#' @param it Specify the time point we are researching\n#' @param X T*d array which stores the data of the time series. T is the length of time and d is the dimension.\n#' @param tau penalty parameter\n#' @param b bandwidth\n#' @return Estimation of transition matrix at time t\ntvvar_fit<-function(it,X,tau,b){\n  T=dim(X)[1]\n  d=dim(X)[2]\n  #compute the kernel weights for t_i\n  ker_weight=vc_weight_epanechnikovker(it/T,1:T,T,b)\n  #compute the kernel weights for t_{i-1}\n  ker_weight_1=vc_weight_epanechnikovker((it-1)/T,1:T,T,b)\n  #sigma_{i-1,0}\n  s10=crossprod(X*drop(ker_weight_1),X)\n  #sigma_{i,0}\n  s00=crossprod(X*drop(ker_weight),X)\n  #sigma_{i-1,1}\n  s11=crossprod(X[1:(T-1),]*drop(ker_weight_1[1:(T-1)]),X[2:T,])\n  #sigma_{i,1}\n  s01=crossprod(X[1:(T-1),]*drop(ker_weight[1:(T-1)]),X[2:T,])\n  #sigma_{i-1,-1}\n  s1_1=crossprod(X[2:T,]*drop(ker_weight_1[2:T]),X[1:(T-1),])\n  #sigma_{i,-1}\n  s0_1=crossprod(X[2:T,]*drop(ker_weight[2:T]),X[1:(T-1),])\n  #solve linear programming\n  f.obj=rep(1,2*d)\n  f.con=matrix(rep(0,4*d^2),nrow=2*d)\n  f.con[1:d,1:d]=-s10\n  f.con[1:d,(d+1):(2*d)]=s10\n  f.con[(d+1):(2*d),1:d]=s00\n  f.con[(d+1):(2*d),(d+1):(2*d)]=-s10\n  f.dir=rep(\"<=\",2*d)\n  f.rhs=matrix(0,2*d,d)\n  A_hat_tmp=sapply(1:d,FUN=function(x){\n    f.rhs[,x]=matrix(c(tau-pmax(s11[,x],s1_1[x,]),\n                       tau+pmin(s01[,x],s0_1[x,])),2*d,1)\n    lp.out=lp('min',f.obj,f.con,f.dir,f.rhs[,x])$solution\n    return(matrix(lp.out[1:d]-lp.out[(1+d):(d+d)],d,1))\n  })\n  A_hat=t(A_hat_tmp)\n  # A_hat=(A_hat_tmp)\n  return(A_hat)\n}\n\n\n#' fit a Ridge_VAR model based on LS with l2 penalty\n#' @param it Specify the time point we are researching\n#' @param X T*d array which stores the data of the time series. T is the length of time and d is the dimension.\n#' @param lam penalty parameter\n#' @param b bandwidth\n#' @return Estimation of transition matrix at time t\nlsvar_fit<-function(it,X,lam,b){\n  T=dim(X)[1]\n  d=dim(X)[2]\n  #compute the kernel weights for t_i\n  ker_weight=vc_weight_epanechnikovker(it/T,1:T,T,b)\n  # #compute the kernel weights for t_{i-1}\n  # ker_weight_1=vc_weight_epanechnikovker((it-1)/T,1:T,T,b)\n  W1=crossprod(X[2:T,]*drop(ker_weight[2:T]),X[1:(T-1),])\n  W2=crossprod(X[1:(T-1),]*drop(ker_weight[2:T]),X[1:(T-1),])\n  # A_hat_LS=solve(W2+lam*diag(d))%*%W1\n  # A_hat_LS=crossprod(chol2inv(chol(W2+lam*diag(d))),W1)#W2 is symmetric\n  A_hat_LS=tcrossprod(W1,chol2inv(chol(W2+lam*diag(d))))#W2 is symmetric\n  return(A_hat_LS)\n}\n\n\n#' fit a MLE_VAR model based on MLE\n#' @param it Specify the time point we are researching\n#' @param X T*d array which stores the data of the time series. T is the length of time and d is the dimension.\n#' @param b bandwidth\n#' @return Estimation of transition matrix at time t\nmlevar_fit<-function(it,X,b){\n  T=dim(X)[1]\n  d=dim(X)[2]\n  #compute the kernel weights for t_i\n  ker_weight=vc_weight_epanechnikovker(it/T,1:T,T,b)\n  W1=crossprod(X[2:T,]*drop(ker_weight[2:T]),X[1:(T-1),])\n  W2=crossprod(X[1:(T-1),]*drop(ker_weight[2:T]),X[1:(T-1),])\n  A_hat_MLE=tcrossprod(W1,chol2inv(chol(W2)))\n  # A_hat_MLE=tcrossprod(W1,solve(W2))\n  # A_hat_MLE=crossprod(chol2inv(chol(W2)),W1)\n  # A_hat_MLE=W1%*%chol2inv(chol(W2))\n  return(A_hat_MLE)\n}\n\n\n\nabso<-function(x){\n  x[x<0]=0\n  return(x)\n}\n#' fit a Lasso_VAR model based on LS with l1 penalty\n#' @param it Specify the time point we are researching\n#' @param X T*d array which stores the data of the time series. T is the length of time and d is the dimension.\n#' @param lam shrinkage parameter\n#' @param b bandwidth\n#' @param alpha stepsize\n#' @param A_old initial matrix 1\n#' @param A_oldold initial matrix 2\n#' @return Estimation of transition matrix at time t\nlavar_fit<-function(it,X,lam,b,alpha,A_old,A_oldold){\n  T=dim(X)[1]\n  d=dim(X)[2]\n  #compute the kernel weights for t_i\n  ker_weight=vc_weight_epanechnikovker(it/T,1:T,T,b)\n  # #compute the kernel weights for t_{i-1}\n  # ker_weight_1=vc_weight_epanechnikovker((it-1)/T,1:T,T,b)\n  # W1=crossprod(X[2:T,]*drop(ker_weight[1:(T-1)]),X[1:(T-1),])\n  # W2=crossprod(X[1:(T-1),]*drop(ker_weight[1:(T-1)]),X[1:(T-1),])\n  W1=crossprod(X[2:T,]*drop(ker_weight[2:T]),X[1:(T-1),])\n  W2=crossprod(X[1:(T-1),]*drop(ker_weight[2:T]),X[1:(T-1),])\n  dis=1\n  step=2\n  alpha=1/max(svd(2*W2)$d)\n  # alpha=1/max(svd(crossprod(X,X))$d)\n  while (dis>10^(-3)){\n    print(c(step,dis))\n    y=A_old+(step-1)/(step+2)*(A_old-A_oldold)\n    tmp=y+2*alpha*(W1-tcrossprod(y,W2))\n    # tmp=y+2*alpha*(W1-crossprod(W2,y))\n    A_new=abso(abs(tmp)-alpha*lam)*sign(tmp)\n    # dis=sum((A_new-A_old)^2)\n    dis=norm(A_new-A_old,type=\"F\")\n    # dis=norm(A_new-y,type=\"F\")\n    # isallzero=(sum(A_new-A_old)==d*d)\n    A_oldold=A_old\n    A_old=A_new\n    step=step+1\n  }\n  return(A_new)\n}\n",
    "created" : 1485066905387.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4119565604",
    "id" : "ECA9000",
    "lastKnownWriteTime" : 1485115220,
    "last_content_update" : 1485115220252,
    "path" : "~/Dropbox/Research/Time-varying VAR/Code/Simulation/tvvar/R/VAR_lib_package_building.R",
    "project_path" : "R/VAR_lib_package_building.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}